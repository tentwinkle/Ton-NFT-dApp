;; Storage
;;
;; int32 seqno
;; int256 public_key
;; slice dapp_owner
;; int64 next_collection_index
;; cell collections_dict

#pragma version >=0.4.0;
#include "imports/stdlib.fc";
#include "imports/messages.fc";
#include "imports/test-libs/message_helpers.fc";
#include "utils/helpers.fc";
#include "utils/op-codes.fc";
#include "utils/constants.fc";
#include "utils/params.fc";

;;const int user_mint_request = 1;
;;const int batch_user_mint_request = 2;

(
  
  int, 
  int, 
  slice, 
  int,
  cell

  ) load_data() inline_ref {

    slice cs = get_data().begin_parse();

    return (
      cs~load_uint(32), ;; int32 seqno
      cs~load_uint(256), ;; int256 public_key
      cs~load_msg_addr(), ;; slice dapp_owner
      cs~load_uint(64), ;; int64 next_collection_index
      (cs.slice_bits() > 0 ? cs~load_dict() : new_dict()) ;; cell collections_dict
    );

}

() save_data(

    int seqno, 
    int public_key,
    slice dapp_owner,
    int next_collection_index,
    cell collections_dict

  ) impure inline {

    set_data(
      begin_cell()
        .store_int(seqno, 32) ;; int32 seqno
        .store_uint(public_key, 256) ;; int256 public_key
        .store_slice(dapp_owner) ;; slice dapp_owner
        .store_uint(next_collection_index, 64) ;; int256 public_key
        .store_dict(collections_dict) ;; cell collections_dict
      .end_cell()
    );

}

slice calculate_collection_address(cell state_init) {
  return begin_cell().store_uint(4, 3)
                     .store_int(workchain, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

() change_owner(slice new_owner_addr) impure {

  (int seqno, int public_key, slice dapp_owner, int next_collection_index, cell collections_dict) = load_data();

  force_chain(new_owner_addr);

  save_data(seqno, public_key, new_owner_addr, next_collection_index, collections_dict);
}

() withdraw_funds(int my_balance, int withdraw_amount) impure {

  throw_unless(407, my_balance + MIN_TONS_FOR_STORAGE > withdraw_amount);

  (_, _, slice dapp_owner,  _, _) = load_data();

  messages::send_empty(withdraw_amount, dapp_owner, NORMAL);
}


() edit_code(cell new_code) impure {

  set_code(new_code);

  cont old_code = get_c3();
  set_c3(new_code.begin_parse().bless());

  throw(0);
}

() main (int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

  slice cs = in_msg_full.begin_parse();

  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();

  if (flags & 1) { 
    return (); 
  } 

  if (in_msg_body.slice_empty?()) { 
    return (); 
  }

  (

    int seqno, 
    int public_key,
    slice dapp_owner,
    int next_collection_index,
    cell collections_dict

  ) = load_data();

  throw_unless(405, equal_slices(dapp_owner, sender_address));

  int op = in_msg_body~load_uint(32);

  if (op == op::change_owner) {

    change_owner(in_msg_body~load_msg_addr());

    return ();
  }

  if (op == op::withdraw_funds) {

    withdraw_funds(my_balance, in_msg_body~load_coins());

    return ();
  }

  if (op == op::edit_dapp_code) {  ;; edit dapp code

    upgrade_current_contract_code(in_msg_body~load_ref());

    return ();

  }

  throw(0xffff);
}

(slice) return_collection_addr_by_id (cell collections_dict, int collection_id) inline_ref {

  (slice value, int f) = udict_get?(collections_dict, 64, collection_id);

  return (value~load_msg_addr());

}

(cell) deploy_collection (cell collections_dict, int amount_for_mint, cell collection_code, cell collection_data, int next_collection_index) impure {

  cell state_init = (generate_init_state_with_data_no_library(collection_code, collection_data)).end_cell(); ;; message_helpers.fc
  
  slice collection_addr = calculate_collection_address(state_init);

  messages::send_with_stateinit(amount_for_mint, collection_addr, state_init, (begin_cell().end_cell()), NORMAL);

  cell new_collections_dict = udict_set(collections_dict, 64, next_collection_index, collection_addr);

  return (new_collections_dict);

}

() mint_notification (cell collections_dict, int collection_id, int item_index, int query_id, int exit_code) impure {

  slice collection_address = return_collection_addr_by_id(collections_dict, collection_id);

  cell msg_body = begin_cell().store_uint(query_id, 64).store_uint(item_index, 64).store_uint(exit_code, 8).end_cell();

  messages::send_via_proxy(ZERO_AMOUNT, collection_address, msg_body, CARRY_REMAINING_GAS);

}

() deploy_nft_item (cell collections_dict, int collection_id, int query_id, int item_index, int amount, cell nft_content) impure {
  
  slice collection_address = return_collection_addr_by_id(collections_dict, collection_id);

  cell msg_body = begin_cell().store_uint(op::deploy_nft_item, 32).store_uint(query_id, 64).store_uint(item_index, 64).store_coins(amount).store_ref(nft_content).end_cell();

  messages::send_via_proxy(ZERO_AMOUNT, collection_address, msg_body, CARRY_REMAINING_GAS);

}

() batch_nft_deploy (cell collections_dict, int collection_id, int query_id, cell deploy_list) impure {

  slice collection_address = return_collection_addr_by_id(collections_dict, collection_id);

  cell msg_body = begin_cell().store_uint(op::batch_nft_deploy, 32).store_uint(query_id, 64).store_ref(deploy_list).end_cell();

  messages::send_via_proxy(ZERO_AMOUNT, collection_address, msg_body, CARRY_REMAINING_GAS);

}

() edit_nft_content (cell collections_dict, int collection_id, int query_id, cell new_content, cell royalty_params) impure {

  slice collection_address = return_collection_addr_by_id(collections_dict, collection_id);

  cell msg_body = begin_cell().store_uint(op::edit_nft_content, 32).store_uint(query_id, 64).store_ref(new_content).store_ref(royalty_params).end_cell();
  
  messages::send_via_proxy(ZERO_AMOUNT, collection_address, msg_body, CARRY_REMAINING_GAS);  ;; sender_addr is provided for security

}

() change_collection_owner (cell collections_dict, int collection_id, int query_id, slice new_owner_addr) impure {

  slice collection_address = return_collection_addr_by_id(collections_dict, collection_id);

  cell msg_body = begin_cell().store_uint(op::change_collection_owner, 32).store_uint(query_id, 64).store_slice(new_owner_addr).end_cell();
  
  messages::send_via_proxy(ZERO_AMOUNT, collection_address, msg_body, CARRY_REMAINING_GAS);

}

() upgrade_collection_code (cell collections_dict, int collection_id, int query_id, cell new_collection_code) impure {

  slice collection_address = return_collection_addr_by_id(collections_dict, collection_id);

  cell msg_body = begin_cell().store_uint(op::upgrade_collection_code, 32).store_uint(query_id, 64).store_ref(new_collection_code).end_cell();

  messages::send_via_proxy(ZERO_AMOUNT, collection_address, msg_body, CARRY_REMAINING_GAS);

}

() recv_external(slice in_msg_body) impure {

    var signature = in_msg_body~load_bits(512);
    slice cs = in_msg_body;

    int msg_segno = cs~load_uint(32);

    (
      int seqno, 
      int public_key,
      slice dapp_owner,
      int next_collection_index,
      cell collections_dict

    ) = load_data();

    throw_unless(33, msg_segno == seqno);
    throw_unless(35, check_signature(slice_hash(in_msg_body), signature, public_key));

    cs.end_parse();
    accept_message();
    cs~touch();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    int collection_id = in_msg_body~load_uint(64);

    ;; Deploy Collection

    if (op == op::deploy_collection) {

      collections_dict = deploy_collection(collections_dict, MIN_DEPLOY_AMOUNT, in_msg_body~load_ref(), in_msg_body~load_ref(), next_collection_index);  

    }

    if (op == op::mint_notification) {  ;; nft has just been initialized

      mint_notification(collections_dict, collection_id, in_msg_body~load_uint(64), query_id, in_msg_body~load_uint(8));

    }

    if (op == op::deploy_nft_item) {

      deploy_nft_item(collections_dict, collection_id, query_id, in_msg_body~load_uint(64), MIN_DEPLOY_AMOUNT, in_msg_body~load_ref());

    }

    if (op == op::batch_nft_deploy) {

      batch_nft_deploy(collections_dict, collection_id, query_id, in_msg_body~load_ref());

    }

    if (op == op::change_collection_owner) {

      change_collection_owner(collections_dict, collection_id, query_id, in_msg_body~load_msg_addr());

    }

    if (op == op::edit_nft_content) {

      edit_nft_content(collections_dict, collection_id, query_id, in_msg_body~load_ref(), in_msg_body~load_ref());

    }

    if (op == op::upgrade_collection_code) {

      upgrade_collection_code(collections_dict, collection_id, query_id, in_msg_body~load_ref());

    }

    save_data(
      seqno + 1, 
      public_key,
      dapp_owner,
      next_collection_index + 1,
      collections_dict
    ); ;; refactor

}

;; Getters

int get_seqno() method_id {
  (int seqno, _, _, _, _) = load_data();
  return seqno;
}

;; (slice) get_owner_addr() method_id {
;;   (_, _, slice dapp_owner, _, _) = load_data();
;;   return dapp_owner;
;; }

var get_deployed_collections_addrs() method_id {

    (_, _, _, _, cell collections_dict) = load_data();

    int idx = 0x7fffffff;  ;; max uint32 
    var l = null();
    do {
        (idx, slice coll, var f) = collections_dict.udict_get_prev?(64, idx);
        if (f) {
            slice coll_addr = coll~load_msg_addr();

            l = cons(coll_addr, l);
        }

    } until ( ~ f)

    return l; ;; return list of deployed_collections_addrs
}
