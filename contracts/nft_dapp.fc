;; Storage
;;
;; int32 seqno
;; int256 public_key
;; slice dapp_owner
;; int64 next_collection_index
;; cell collections_dict

#pragma version >=0.4.0;
#include "imports/stdlib.fc";
#include "imports/messages.fc";

const int user_mint_request = 1;
const int batch_user_mint_request = 2;

(
  
  int, 
  int, 
  slice, 
  int, 
  cell

  ) load_data() inline {

    slice cs = get_data().begin_parse();

    return (
      cs~load_uint(32), ;; int32 seqno
      cs~load_uint(256), ;; int256 public_key
      cs~load_msg_addr(), ;; slice dapp_owner
      cs~load_uint(64), ;; int64 next_collection_index
      (cs.slice_bits() > 0 ? cs~load_dict() : new_dict()) ;; cell collections_dict
    );

}

() save_data(

    int seqno, 
    int public_key,
    slice dapp_owner,
    int next_collection_index
    cell collections_dict

  ) impure inline {

    set_data(
      begin_cell()
        .store_int(seqno, 32) ;; int32 seqno
        .store_uint(public_key, 256) ;; int256 public_key
        .store_slice(dapp_owner) ;; slice dapp_owner
        .store_uint(next_collection_index, 64) ;; int256 public_key
        .store_dict(collections_dict) ;; cell collections_dict
      .end_cell()
    );

}

() store_config_params(int index, cell value) impure {
  var cs = get_data().begin_parse();
  var config = cs~load_ref();

  config~idict_set_ref(32, index, value);

}

slice calculate_collection_address(cell state_init) {
  return begin_cell().store_uint(4, 3)
                     .store_int(workchain(), 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

(cell) calculate_msg_body_for_deploy_request (int item_index) inline {
    return (
        begin_cell()
            .store_uint(user_mint_request, 32) ;; op
            .store_uint(item_index, 64)
        .end_cell()
    );
}

() send_deploy_request (slice collection_addr) impure {

    cell msg_body = (
        begin_cell()
            .store_uint(user_mint_request, 32)
            .
    )

    send_raw_message(msg, mode);

}

() main (slice in_msg_body, cell in_msg_full) impure {

  slice cs = in_msg_full.begin_parse();

  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();

  if (flags & 1) { return (); } ;; ;; ignore all bounced messages
  if (in_msg_body.slice_empty?()) { return (); } ;; выкидываем, если пусто в msg_body

  (

    int seqno, 
    int public_key,
    slice dapp_owner,
    int next_collection_index
    cell collections_dict

  ) = load_data();

  throw_unless(405, equal_slices(collection_address, sender_address));

  if (op == op::change_owner) {
    
  }

  if (op == op::withdraw_funds) {

  }

}

(slice) return_collection_addr_by_id (int collection_id) inline {

}

(cell) deploy_collection (cell collections_dict, cell collection_code, cell collection_data) impure {

    cell state_init = generate_init_state_with_data_no_library(current_collection_code, current_collection_data); ;; message_helpers.fc
    slice current_collection_addr = calculate_collection_address(state_init);
    messages::send_with_stateinit(amount_for_mint, current_collection_addr, state_init, (begin_cell().end_cell()), NORMAL);
    cell new_collections_dict = idict_set(collections_dict, 64, index, current_collection_addr);
    return (new_collections_dict);

}

() mint_notification () {
  
}

() mint_nft_request () {
  
}

() edit_nft_request () {

}

() edit_dapp_code () {

}

() edit_collection_code () {

}

() recv_external(slice in_msg_body) impure {

    var signature = in_msg_body~load_bits(512);
    var cs = in_msg_body;

    var msg_segno = cs~load_uint(32);

    (

      int seqno, 
      int public_key,
      slice dapp_owner,
      int next_collection_index
      cell collections_dict

    ) = load_data();

    throw_unless(33, msg_segno == stored_seqno);
    throw_unless(35, check_signature(slice_hash(in_msg_body), signature, public_key));

    cs.end_parse();
    accept_message();

    ;; we need to load everything from ds here

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    slice collection_id = in_msg_body~load_msg_addr();  ;; collection_id is collection address
    int exit_code = in_msg_body~load_uint(8);

    int collection_id = in_msg_body~load_uint(64);

    ;; Deploy Collection

    if (op == op::deploy_collection) {

      collections_dict = deploy_collection(collections_dict, in_msg_body~load_ref(), in_msg_body~load_ref()); ;; loads 

    }

    if (op == op::mint_notification) {  ;; nft has just been initialized

      mint_notification(collection_id, item_index, query_id, exit_code);

    }

    if (op == op::mint_nft_request) {

      mint_nft_request(collection_id, MIN_DEPLOY_AMOUNT, nft_content);

    }

    if (op == op::edit_nft_request) {

      edit_nft_request(collection_id, item_index, deploy_amount, nft_content);

    }

    if (op == op::edit_dapp_code) {

      edit_dapp_code(

        ;; coming soon

      );

    }

    if (op == op::edit_collection_code) {

      edit_collection_code(

        ;; coming soon
        
      );

    }

    save_data(
      seqno + 1, 
      public_key, 
      collections_dict
    ); ;; refactor

}

;; Getters

int get_seqno() method_id {
  (_, int stored_seqno, _, _, _) = load_data();
  return stored_seqno;
}

var get_deployed_collections_addrs() method_id {

    (_, _, _, cell collections, _) = load_data();

    int cursor = 0x7fffffff;  ;; max uint32 
    var l = null();
    do {
        (cursor, slice coll, var f) = collections.idict_get_prev?(32, cursor);
        if (f) {
            slice coll_addr = coll~load_msg_addr();

            l = cons(coll_addr, l);
        }

    } until ( ~ f)

    return l; ;; return list of deployed_collections_addrs
}

() get_collection_addr_by_id (int collection_id) method_id {
  return return_collection_addr_by_id(collection_id);
}